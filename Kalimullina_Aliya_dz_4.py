
#1. Проанализировать скорость и сложность одного любого алгоритма, разработанных в рамках домашнего задания первых трех уроков.
#Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.

# Найти сумму n элементов следующего ряда чисел: 1 -0.5 0.25 -0.125 ...Количество элементов (n) вводится с клавиатуры.
import timeit

n = int(input('Введите количество элементов ряда 1 -0.5 0.25 -0.125... : '))
"""O(n)-линейная сложность"""
def func_cicle(n):
  el = 1
  sums = 0
  while n > 0:
    sums += el
    el /= -2
    n -= 1
  return sums
#func_cicle(n)

def func_recur(n):
  """O(n) -линейная сложность"""
  r = 0
  if n <= 0:
    return []
  if n%2 == 0:
    r = [(1/-2 ** (n-1))] 
  else:
    r = [(1/2 ** (n-1))] 
  return r + func_recur(n-1)
#print(sum(func_recur(n)))

print(
  timeit.timeit(
    "func_cicle(n)",
    setup = "from  __main__ import func_cicle, n",
    number = 100))

print(
  timeit.timeit(
    "sum(func_recur(n))",
    setup = "from  __main__ import func_recur, n",
    number = 100))
"""
Результат при n = 10
0.000147980001202086
0.0009327099978690967

Результат при n = 990
0.10921517799943103
1.222467866999068
Цикл for выполняется быстрее, чем рекурсия """

# Написать два алгоритма нахождения i-го по счёту простого числа.
# Без использования «Решета Эратосфена»;
# Используя алгоритм «Решето Эратосфена»
# Примечание ко всему домашнему заданию: Проанализировать скорость и сложность алгоритмов. Результаты анализа сохранить в виде комментариев в файле с кодом.
i = int(input('Введите i-ое по счету простое число: '))

def not_eratosfen(i):
  """Без использования решета Эратосфена
  O(n^2) -линейная сложность"""
  count = 1
  n = 2
  while count <= i:
    t = 1
    flag = True
    while t <= n:
      if n % t == 0 and t != 1 and t != n:
        flag = False
        break
      t += 1
    if flag:
      if count == i:
        break
      count += 1
    n += 1
  return n
#print(not_eratosfen(i))

def eratosfen(i):
  """С использованием решета Эратосфена
  O(n log(n)) -линейная сложность"""
  n = 10000
  a = [s for s in range(n+1)]
  a[1] = 0 # первый элемент вычеркиваем
  k = 2 # цикл начнем со 2 элемента
  while k <= n/2:
    if a[k] !=0:
      j = k+k
      while j<=n:
        a[j]=0
        j = j+k
    k = k + 1
  return([k for k in a if a[k] != 0][i-1])


print(
  timeit.timeit(
    "not_eratosfen(i)",
    setup = "from  __main__ import not_eratosfen, i",
    number = 100))

print(
  timeit.timeit(
    "eratosfen(i)",
    setup = "from  __main__ import eratosfen, i",
    number = 100))




"""Результат:
(при значении 10):
  без использования решета Эратосфена: 0.00297007900007884
  с использованием решета Эратосфена:  1.1328007869997236
(при значении 100):
  без использования решета Эратосфена: 1.8241673189986614
  с использованием решета Эратосфена:  3.1412937519999105
(при значении 300):
  без использования решета Эратосфена: 23.407616552001855
  с использованием решета Эратосфена: 2.9211433000018587 
при больших значениях ноут подвисает
Вывод: использование функиции решета Эратосфена эффективно при больших значениях i
"""
